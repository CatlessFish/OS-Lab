## 常见问题

#### 关于qemu的说明

qemu使用完后请记得先 `Ctrl+A`，然后 `x` 将其关掉

#### 如何开启 debug 调试？

在 `build` 文件夹下输入命令 `make qemu-debug` 就可以让 qemu 在debug模式下运行，启动新的窗口（或者终端），在 build 目录下运行 `make debug `即可进入 gdb 调试命令行。

#### 为什么去除掉 arch_stop_cpu 会输出4个a？（lab1）

因为在lab1中， main函数带有 NO_RETURN 标识，而此时 if 条件判断一旦为否 main函数就会返回，可能就是为了不让 main 函数返回，编译器会把其中的 if 判断语句优化掉

#### 为啥要将 bss 段初始化为0？能不能在define early init做这个，为什么？NO_BSS段是做什么用的？

0. bss是指链接器产生的未初始化数据段，链接器将程序的未初始化的数据和初始化为0的数据放在这里，运行时再由（操作）系统初始化并分配实际的内存空间，这样可以节约空间。而我们运行的就是操作系统，此前没有其它程序会帮我们初始化，所以需要我们自己初始化，因为初始化为0的数据也会再这里，所以我们的系统运行时需要先把bss段清零，防止相关的变量的初始值与定义时不符。
1. 如果这么做的话，后续如果 early_init 中的函数使用了初始化为0的变量可能就会出错，因为同在early_init 中的初始化函数的运行顺序是没有保证的（顺序由链接器决定，不建议关注）
2. NO_BSS 指定变量不会出现在 bss 段中

#### _start依旧后续的代码运行的实际物理地址是 0x80000，而链接器指定这块的地址是 0xffff000000080000，为什么仍能运行？（lab1）

0. 在开启内核页表之后：高位为 0xffff 的地址会在 MMU （Memory Management Unit）的翻译后再取地址（比如 0xffff000000080000会映射到0x80000），因此这时的代码和链接器指定的地址正好相吻合；
1. 在内核页表开启之前：因为内核页表是在 _start 中开启的，那么在内核页表开启之前是怎么运行的呢？

通过debug，利用 `display /10i $pc` 打印10条汇编指令，我们发现包括 main 在内的各种地址标识的绝对地址都是 0xffff开头，如果在开启页表前就直接跳转到这些函数入口肯定是无效的。

```assembly
ldr    x1, =<name>   #x1 存入 name 的链接时地址
ldr    x2, =12345    #x2 存入 12345
_start: 0xffff000000080000
entry： 0xffff00000008003c
main: 0xffff000000080118
```

那么是怎么跳转到对应的地址的呢？

写start.S的时候刻意在开启虚拟地址之前把代码都写成PIE(Position Independent Executables)，所以虽然实际PC不是链接器中声明的PC，仍然能执行；

```assembly
adr    x0, <name>  #x0存入 name 相对pc的实际地址
_start: 0x80000
entry: 0x8003c
```

等一系列初始化完成后，跳转到main的地址处（0xffff000000080118），该地址会被 MMU 翻译成0x80118物理地址处，然后开始取值运行。



#### 关于字节对齐

`*(u64*)p=0` 这样的语法要求p是8字节对齐，虽然lab1中的edata和end满足要求，但是不能保证以后加了东西还满足要求

#### 关于链接器符号的说明

符号代表那个位置的地址，符号的指针才是内容